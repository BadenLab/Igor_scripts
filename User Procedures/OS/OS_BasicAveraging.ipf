#pragma rtGlob#als=3		// Use modern global access method and strict wave access.
#include "OS_AveragingSuite"

function OS_BasicAveraging()

// 1 // check for Parameter Table
if (waveexists($"OS_Parameters")==0)
	print "Warning: OS_Parameters wave not yet generated - doing that now..."
	OS_ParameterTable()
	DoUpdate
endif
wave OS_Parameters
// 2 //  check for Detrended Data stack
variable Channel = OS_Parameters[%Data_Channel]
if (waveexists($"wDataCh"+Num2Str(Channel)+"_detrended")==0)
	print "Warning: wDataCh"+Num2Str(Channel)+"_detrended wave not yet generated - doing that now..."
	OS_DetrendStack()
endif
// 3 //  check for ROI_Mask
if (waveexists($"ROIs")==0)
	print "Warning: ROIs wave not yet generated - doing that now (using correlation algorithm)..."
	OS_AutoRoiByCorr()
	DoUpdate
endif
// 4 //  check if Traces and Triggers are there
if (waveexists($"Triggertimes")==0)
	print "Warning: Traces and Trigger waves not yet generated - doing that now..."
	OS_TracesAndTriggers()
	DoUpdate
endif

// flags from "OS_Parameters"
variable Display_averages = OS_Parameters[%Display_Stuff]
variable use_znorm = OS_Parameters[%Use_Znorm]
variable LineDuration = OS_Parameters[%LineDuration]
variable Triggermode = OS_Parameters[%Trigger_Mode]
variable Ignore1stXseconds = OS_Parameters[%Ignore1stXseconds]
variable IgnoreLastXseconds = OS_Parameters[%IgnoreLastXseconds]
variable AverageStack_make = OS_Parameters[%AvgStack_make]
variable X_cut = OS_Parameters[%LightArtifact_cut]
variable nStimSegments =  OS_Parameters[%Stim_Marker]
variable nTrace_Max_full =  OS_Parameters[%PlotOnlyMeans]
variable nTrace_Max_trace =  OS_Parameters[%PlotOnlyHeatMap]
variable nLines_Lumped = OS_Parameters[%nLines_lumped]
variable Make_QCprojection = OS_Parameters[%QCProjection_make]
variable TriggersPerStim = OS_Parameters[%QCProj_TriggersPerStim]
variable QCProjection_binning = OS_Parameters[%QCProjection_binning]
variable FOV_at_zoom065 = OS_Parameters[%FOV_at_zoom065] * (OS_Parameters[%fullFOVSize]/0.5)

// data handling
wave wParamsNum // Reads data-header
string input_name = "wDataCh"+Num2Str(Channel)+"_detrended"
string traces_name = "Traces"+Num2Str(Channel)+"_raw"
if (use_znorm==1)
	traces_name = "Traces"+Num2Str(Channel)+"_znorm"
endif
string tracetimes_name = "Tracetimes"+Num2Str(Channel)
duplicate /o $input_name InputStack
duplicate /o $traces_name InputTraces
duplicate /o $tracetimes_name InputTraceTimes

wave Triggertimes
variable nF = DimSize(InputTraces,0)
variable nRois = DimSize(InputTraces,1)
variable nX = DimSize(InputStack,0)
variable nY = DimSize(InputStack,1)

//wave StimArtifact // generated by "Traces and Triggers"

string output_name1 = "Snippets"+Num2Str(Channel)
string output_name2 = "Averages"+Num2Str(Channel)
string output_name3 = "AverageStack"+Num2Str(Channel)
string output_name4 = "SnippetsTimes"+Num2Str(Channel) // andre addition 2016 04 13
//string output_name5 = "AverageStimArtifact"+Num2Str(Channel) 


variable tt,rr,ll,pp,xx,yy,ff
variable bbx, bby // needed for QC projection binning

variable zoom = wParamsNum(30) // extract zoom
variable px_Size = (0.65/zoom * FOV_at_zoom065)/nX // microns

// Get Snippet Duration, nLoops etc..
variable nTriggers
variable Ignore1stXTriggers = 0
variable IgnoreLastXTriggers = 0
variable last_data_time_allowed = InputTraceTimes[nF-1][0]-IgnoreLastXseconds


for (tt=0;tt<Dimsize(triggertimes,0);tt+=1)
	if (NumType(Triggertimes[tt])==0)
		if (Ignore1stXseconds>Triggertimes[tt])
			Ignore1stXTriggers+=1
		endif
		if (Triggertimes[tt]<=last_data_time_allowed)
			nTriggers+=1
		endif
	else
		break
	endif
endfor
if (Ignore1stXTriggers>0)
	print "ignoring first", Ignore1stXTriggers, "Triggers"
endif
variable SnippetDuration = Triggertimes[TriggerMode+Ignore1stXTriggers]-Triggertimes[0+Ignore1stXTriggers] // in seconds
variable nLoops = floor((nTriggers-Ignore1stXTriggers-IgnoreLastXTriggers) / TriggerMode)

variable Last_Snippet_Length = last_data_time_allowed - ((nLoops * SnippetDuration) + Triggertimes[Ignore1stXTriggers])  

print nTriggers, "Triggers, ignoring 1st",  Ignore1stXTriggers, "and last", IgnoreLastXTriggers, "and skipping in", TriggerMode, "gives", nLoops, "complete loops"
print "Note: Last", IgnoreLastXseconds, "s are also clipped"

if (Last_Snippet_Length<SnippetDuration)
	IgnoreLastXTriggers = TriggerMode
endif

// make line precision timestamped trace arrays
variable FrameDuration = nY*LineDuration // in seconds
variable nPoints = (nF * FrameDuration) / (LineDuration*nLines_Lumped)
make /o/n=(nPoints,nRois) OutputTracesUpsampled = 0 // in line precision - deafult 500 Hz
make /o/n=(nPoints,nRois) OutputTimesUpsampled = 0 // Andre 2016 04 13
for (rr=0;rr<nRois;rr+=1)
// for linear interpolation
	make /o/n=(nF*nY) CurrentTrace = NaN
	make /o/n=(nF*nY) CurrentTime = NaN	// Andre addition 2016 04 13
	setscale x,InputTraceTimes[0][rr],InputTraceTimes[nF-1][rr],"s" CurrentTrace
	for (ff=0;ff<nF-1;ff+=1)
		for (yy=0;yy<nY/nLines_Lumped; yy+=1)
			CurrentTrace[ff*(nY/nLines_Lumped)+yy]=(InputTraces[ff+1][rr]*yy+InputTRaces[ff][rr]*((nY/nLines_Lumped)-yy))/(nY/nLines_Lumped)
			CurrentTime[ff*(nY/nLines_Lumped)+yy]=(InputTraceTimes[ff+1][rr]*yy+InputTraceTimes[ff][rr]*((nY/nLines_Lumped)-yy))/(nY/nLines_Lumped) // andre addition 2016 04 13
		endfor
	endfor
	variable lineshift = round(InputTraceTimes[0][rr] / (LineDuration*nLines_Lumped))
	OutputTracesUpsampled[lineshift,nPoints-4*FrameDuration/(LineDuration*nLines_Lumped)][rr] = CurrentTrace[p-lineshift] // ignores last 4 frames of original recording to avoid Array overrun
	OutputTimesUpsampled[lineshift,nPoints-4*FrameDuration/(LineDuration*nLines_Lumped)][rr] = CurrentTime[p-lineshift] // andre additinon 2016 04 13
endfor

// Snipperting and Averaging

make /o/n=(SnippetDuration * 1/(LineDuration*nLines_Lumped),nLoops,nRois) OutputTraceSnippets = 0 // in line precision
make /o/n=(SnippetDuration * 1/(LineDuration*nLines_Lumped),nLoops,nRois) OutputTimeSnippets = 0 // Andre 2016 04 13
make /o/n=(SnippetDuration * 1/(LineDuration*nLines_Lumped),nRois) OutputTraceAverages = 0 // in line precision

setscale /p x,0,(LineDuration*nLines_Lumped),"s" OutputTraceSnippets,OutputTraceAverages

for (rr=0;rr<nRois;rr+=1)
	for (ll=0;ll<nLoops;ll+=1)
		OutputTraceSnippets[][ll][rr]=OutputTracesUpsampled[p+Triggertimes[ll*TriggerMode+Ignore1stXTriggers]/(LineDuration*nLines_Lumped)][rr]
		OutputTraceAverages[][rr]+=OutputTracesUpsampled[p+Triggertimes[ll*TriggerMode+Ignore1stXTriggers]/(LineDuration*nLines_Lumped)][rr]/nLoops
		OutputTimeSnippets[][ll][rr] = OutputTimesUpsampled[p+Triggertimes[ll*TriggerMode+Ignore1stXTriggers]/(LineDuration*nLines_Lumped)][rr]		// Andre 2016 04 13
	endfor
endfor


// Calculate Quality criterion:

make /o/n=(nRois) QualityCriterion = NaN // (1 - variance of mean / mean of variance)
make /o/n=(nRois) MoV = NaN // (1 - variance of mean / mean of variance)
make /o/n=(nRois) VoM = NaN // (1 - variance of mean / mean of variance)

for (rr=0;rr<nRois;rr+=1)
	make /o/n=(SnippetDuration) currentwave = OutputTraceAverages[p][rr]
	Wavestats/Q currentwave
	variable variance_of_mean = V_SDev^2
	VoM[rr]=variance_of_mean
	variable mean_of_variance = 0
	make /o/n=(nLoops) currentwave2 = naN
	for (ll=0;ll<nLoops;ll+=1)
		make /o/n=(SnippetDuration * 1/(LineDuration*nLines_Lumped)) currentwave = OutputTraceSnippets[p][ll][rr]//-OutputTraceAverages[p][rr]
		Wavestats/Q currentwave
		currentwave2[ll]=V_SDev^2
	endfor
	Wavestats/Q currentwave2
	mean_of_variance=V_Avg
	MoV[rr]=mean_of_variance
	
	QualityCriterion[rr]= variance_of_mean / Mean_of_variance
endfor


// make average stack (optional) - frame precision

variable CurrentTriggerFrame
if (AverageStack_make>0)
	print "Generating AverageStack and QC projection"
	make /o/n=(nX-X_Cut,nY) OutputStack_avg = 0
	make /o/n=(nX-X_Cut,nY,SnippetDuration/FrameDuration) OutputStack = 0 // at framerate
	for (xx=0;xx<nX-X_Cut;xx+=1)
		for (yy=0;yy<nY;yy+=1)
			variable CurrentSubstraction = 0
			if (AverageStack_make>1) // >1 is extra processing
				make /o/n=(nF) tempwave = InputStack[xx+X_Cut][yy][p]
				WaveStats/Q tempwave
				if (Averagestack_make==2)
					CurrentSubstraction=V_Min
				elseif (Averagestack_make==3)
					CurrentSubstraction=V_Avg
				elseif (Averagestack_make==4)
					CurrentSubstraction=StatsMedian(tempwave)
				endif
			endif
			
			for (ll=0;ll<nLoops;ll+=1)	// average across loops
				CurrentTriggerFrame = (Triggertimes[ll*TriggerMode+Ignore1stXTriggers])/FrameDuration
				Multithread OutputStack[xx][yy][]+=InputStack[xx+X_Cut][yy][r+CurrentTriggerFrame] - CurrentSubstraction
			endfor
		endfor
	endfor
	OutputStack[][][]/=nLoops
		
	duplicate /o OutputStack $output_name3 // within Igor it keeps the non flipped 32 bit one
	//Imagesave /s/f/t="tiff" OutputStack as "AverageStack"
	OS_AveragingSuite_Chopup()
endif

////////////////////////////////////////////
// QC projection, including per trigger

variable TriggerDivider = Ceil(Triggermode/TriggersPerStim)

if (Make_QCprojection==1)
	print "Computing QC projections..."

	make /o/n=(nX-X_Cut,nY) QC_projection = NaN
	make /o/n=(nX-X_Cut,nY,TriggerDivider) QC_projection_perTrigger = NaN
	
	setscale /p x,-nX/2*px_Size,px_Size,"µm" QC_projection, QC_projection_perTrigger
	setscale /p y,-nY/2*px_Size,px_Size,"µm"  QC_projection, QC_projection_perTrigger
	
	for (xx=0;xx<nX-X_Cut;xx+=QCProjection_binning)
		for (yy=0;yy<nY;yy+=QCProjection_binning)
			for (tt=0;tt<TriggerDivider;tt+=1)	
				if (tt==0) // for full QC, rather than per trigger
					make /o/n=(nLoops) currentwave2_full = NaN //  mean of variance (for QC projection)
					make /o/n=(SnippetDuration/FrameDuration) currentwave3_full = 0 // for mean
				endif
				make /o/n=(nLoops) currentwave2 = NaN //  mean of variance (for QC projection)
				make /o/n=(ceil((SnippetDuration/FrameDuration)/TriggerDivider)) currentwave3 = 0 // for mean
				for (ll=0;ll<nLoops;ll+=1)	// average across loops
					CurrentTriggerFrame = (Triggertimes[ll*TriggerMode+Ignore1stXTriggers+tt*TriggersPerStim])/FrameDuration
					if (QCProjection_binning==1) // single pixel standard
						make /o/n=(ceil((SnippetDuration/FrameDuration)/TriggerDivider)) currentwave = InputStack[xx+X_Cut][yy][p+CurrentTriggerFrame]
						if (tt==0)
							make /o/n=(SnippetDuration/FrameDuration) currentwave_full = InputStack[xx+X_Cut][yy][p+CurrentTriggerFrame]
						endif
					else // add up the corresponding pixels & take mean
						make /o/n=(ceil((SnippetDuration/FrameDuration)/TriggerDivider)) currentwave = 0
						if (tt==0)
							make /o/n=(SnippetDuration/FrameDuration) currentwave_full = 0
						endif
						for (bbx=0;bbx<QCProjection_binning;bbx+=1)
							for (bby=0;bby<QCProjection_binning;bby+=1)
								currentwave+=InputStack[xx+X_Cut+bbx][yy+bby][p+CurrentTriggerFrame]/(QCProjection_binning^2)
								if (tt==0)
									currentwave_full+=InputStack[xx+X_Cut+bbx][yy+bby][p+CurrentTriggerFrame]/(QCProjection_binning^2)
								endif
							endfor
						endfor
					endif
					Wavestats/Q currentwave			
					currentwave2[ll]=V_SDev^2
					Wavestats/Q currentwave_full			
					currentwave2_full[ll]=V_SDev^2
					currentwave3[]+=currentwave[p]/nLoops
					if (tt==0)
						currentwave3_full[]+=currentwave_full[p]/nLoops
					endif
				endfor
				Wavestats/Q currentwave3
				variance_of_mean = V_SDev^2
				Wavestats/Q currentwave2
				mean_of_variance=V_Avg
				if (QCProjection_binning==1)
					QC_projection_perTrigger[xx][yy][tt]= variance_of_mean / Mean_of_variance
				else
					for (bbx=0;bbx<QCProjection_binning;bbx+=1) // paint all corresponding pixels to same QC
						for (bby=0;bby<QCProjection_binning;bby+=1)
							QC_projection_perTrigger[xx+bbx][yy+bby][tt]= variance_of_mean / Mean_of_variance
						endfor
					endfor	
				endif
				
				if (tt==0)
					Wavestats/Q currentwave3_full
					variance_of_mean = V_SDev^2
					Wavestats/Q currentwave2_full
					mean_of_variance=V_Avg
					if (QCProjection_binning==1)
						QC_projection[xx][yy]= variance_of_mean / Mean_of_variance
					else
						for (bbx=0;bbx<QCProjection_binning;bbx+=1) // paint all corresponding pixels to same QC
							for (bby=0;bby<QCProjection_binning;bby+=1)
								QC_projection[xx+bbx][yy+bby]= variance_of_mean / Mean_of_variance
							endfor
						endfor	
					endif
				endif
				
			endfor
		endfor
	endfor
	


endif



// export handling
duplicate /o OutputTraceSnippets $output_name1
duplicate /o OutputTraceAverages $output_name2
duplicate /o OutputTimeSnippets $output_name4


	
// display

if (Display_averages==1)
	display /k=1
	make /o/n=(1) M_Colors
	Colortab2Wave Rainbow256
	
	if (nStimSegments>0) // if there is a resgular stimulus to be plotted
		make /o/n=(nStimSegments) StimMarker = 1
		variable counter
		for (counter=1;counter<nStimSegments;counter+=2)
			StimMarker[counter]=0
		endfor
		Setscale x,0,SnippetDuration,"s" StimMarker

		Appendtograph /l=StimY StimMarker
		ModifyGraph fSize=8,noLabel(StimY)=2,axThick(StimY)=0,lblPos(StimY)=47;DelayUpdate
		ModifyGraph axisEnab(StimY)={0.05,1},freePos(StimY)={0,kwFraction}
		 ModifyGraph mode=5,hbFill=2
		ModifyGraph rgb(StimMarker)=(56576,56576,56576)
		if (nROIs>nTrace_Max_trace)
			ModifyGraph hbFill=0 // if heatmap, then just plot the skeleton
		endif
	endif

	
	if (nROIs>nTrace_Max_trace)
		print "more than", nTrace_Max_trace, "ROIs. Just plotting heatmap of means" 
	elseif (nROIs>nTrace_Max_full)
		print "more than", nTrace_Max_full, "ROIs. Skipping individual repeats in the plot" 
	endif
	
	if (nROIs<=nTrace_Max_trace)
		for (rr=0;rr<nRois;rr+=1)
			string YAxisName = "YAxis_Roi"+Num2Str(rr)
			string tracename
			
			if (nROIs<=nTrace_Max_full)
				for (ll=0;ll<nLoops;ll+=1)
					tracename = output_name1+"#"+Num2Str(rr*nLoops+ll)
					if (ll==0 && rr==0)
						tracename = output_name1
					endif
					Appendtograph /l=$YAxisName $output_name1[][ll][rr]
					ModifyGraph rgb($tracename)=(52224,52224,52224)
				endfor	
			endif
			tracename = output_name2+"#"+Num2Str(rr)
			if (rr==0)
				tracename = output_name2
			endif
			Appendtograph /l=$YAxisName $output_name2[][rr]
			variable colorposition = 255 * (rr+1)/nRois
			ModifyGraph rgb($tracename)=(M_Colors[colorposition][0],M_Colors[colorposition][1],M_Colors[colorposition][2])
			ModifyGraph lsize($tracename)=1.5
					
			variable plotfrom = (1-((rr+1)/nRois))*0.8+0.2
			variable plotto = (1-(rr/nRois))*0.8+0.2
			
			ModifyGraph fSize($YAxisName)=8,axisEnab($YAxisName)={plotfrom,plotto};DelayUpdate
			ModifyGraph freePos($YAxisName)={0,kwFraction};DelayUpdate
			Label $YAxisName "\\Z10"+Num2Str(rr)
			ModifyGraph noLabel($YAxisName)=1,axThick($YAxisName)=0;DelayUpdate
			ModifyGraph lblRot($YAxisName)=-90
		endfor
	else
		Appendimage /l=HeatMapY $output_name2
		ModifyGraph fSize=8,lblPos(HeatMapY)=47,axisEnab(HeatMapY)={0.05,1};DelayUpdate
		ModifyGraph freePos(HeatMapY)={0,kwFraction};DelayUpdate
		Label HeatMapY "\\Z10ROI"
	endif
	
	ModifyGraph fSize(bottom)=8,axisEnab(bottom)={0.05,1};DelayUpdate
	Label bottom "\\Z10Time (\U)"
endif

if (Make_QCprojection==1)
	Display /k=1
	variable WinWidth = 800
	variable WinHeight = (nY/nX) * WinWidth/3	
	ModifyGraph width=WinWidth,height=WinHeight

	
	Appendimage /r=YY /b=QCIndX QC_projection_perTrigger

	// Trigger box	
	variable/G gCurrentTrigger = 0
	
	String iName= WMTopImageGraph()		// find one top image in the top graph window
	Wave w= $WMGetImageWave(iName)	// get the wave associated with the top image.
	String/G imageName2=nameOfWave(w)
	Variable/G gLeftLim=0,gRightLim=TriggerDivider-1,gTrigger=0
	GetWindow kwTopWin,gsize
	String cmd
	SetVariable TriggerVal,pos={V_left+20,V_top+20},size={80,14}
	SetVariable TriggerVal,limits={0,Triggermode-1,1},title="Trig",proc=OS_ExecuteSliderVar_QC
	sprintf cmd,"SetVariable TriggerVal,value=%s",GetDataFolder(1)+"gCurrentTrigger"
	Execute cmd

	//
	Appendimage /r=YY /b=AverageX Stack_SD
	Appendimage /r=YY /b=QCFullX QC_projection
	
	ModifyGraph fSize=8,freePos={0,kwFraction}
	ModifyGraph axisEnab(YY)={0,1},axisEnab(QCIndX)={0.08,0.38},axisEnab(QCFullX)={0.39,0.69},axisEnab(AverageX)={0.7,1}

	Label AverageX "\\Z10SD projection";DelayUpdate
	Label QCFullX "\\Z10QC projection total";DelayUpdate
	Label QCIndX "\\Z10QC projection by Stimulus";DelayUpdate
	ModifyGraph lblPos(AverageX)=47,lblPos(QCFullX)=47,lblPos(QCIndX)=47
	ModifyGraph lblPos=47
	ModifyGraph lblPos=47
	ModifyGraph noLabel=1,axThick=0
	ModifyGraph noLabel(YY)=2
	
	DoUpdate
	ModifyGraph width=0,height=0
endif


// cleanup
killwaves InputTraces, InputTraceTimes,CurrentTrace,OutputTracesUpsampled,OutputTraceSnippets,OutputTraceAverages,OutputStack,OutputStack_avg
killwaves currentwave2, currentwave // AverageStack_8bit, currentwave, currentwave_Hist
killwaves OutputTimeSnippets, OutputTimesUpsampled, CurrentTime

killwaves inputstack

end


//*******************************************************************************************************
function OS_ExecuteSlider_QC(name, value, event)
	String name			// name of this slider control
	Variable value		// value of slider
	Variable event		// bit field: bit 0: value set; 1: mouse down, //   2: mouse up, 3: mouse moved
	
	NVAR gCurrentTrigger

	SVAR imageName2
	ModifyImage  $imageName2 plane=(gCurrentTrigger)	
	return 0				// other return values reserved
end
//*******************************************************************************************************
Function OS_ExecuteSliderVar_QC(sva) : SetVariableControl
	STRUCT WMSetVariableAction &sva

	switch( sva.eventCode )
		case 1: // mouse up
		case 2: // Enter key
		// comment the following line if you want to disable live updates.
		case 3: // Live update
			Variable dval = sva.dval
			OS_ExecuteSlider_QC("",0,0)
			break
	endswitch

	return 0
End